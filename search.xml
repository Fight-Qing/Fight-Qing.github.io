<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot参数校验——Validator框架</title>
      <link href="/2023/07/17/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E2%80%94%E2%80%94Validator%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/07/17/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E2%80%94%E2%80%94Validator%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot参数校验——Validator框架"><a href="#SpringBoot参数校验——Validator框架" class="headerlink" title="SpringBoot参数校验——Validator框架"></a>SpringBoot参数校验——Validator框架</h1><h2 id="为什么要用validator"><a href="#为什么要用validator" class="headerlink" title="为什么要用validator"></a>为什么要用validator</h2><p>​在日常的接口开发中，为了防止非法参数对业务造成影响，经常需要对接口的参数做校验，例如登录的时候需要校验用户名密码是否为空，创建用户的时候需要校验邮件、手机号码格式是否准确。靠代码对接口参数一个个校验的话就太繁琐了，代码可读性极差。</p><p>​<strong>Validator框架</strong>就是为了解决开发人员在开发的时候少写代码，提升开发效率；Validator专门用来进行接口参数校验，例如常见的必填校验，email格式校验，用户名必须位于6到12之间 等等…</p><h2 id="集成Validator校验框架"><a href="#集成Validator校验框架" class="headerlink" title="集成Validator校验框架"></a>集成Validator校验框架</h2><h3 id="引入依赖包"><a href="#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：从<code>springboot-2.3</code>开始，校验包被独立成了一个<code>starter</code>组件，所以需要引入validation和web，而<code>springboot-2.3</code>之前的版本只需要引入 web 依赖就可以了。</p></blockquote><h3 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h3><table><thead><tr><th>验证注解</th><th>验证的数据类型</th><th>说明</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>Boolean,boolean</td><td>验证注解的元素值是false</td></tr><tr><td>@AssertTrue</td><td>Boolean,boolean</td><td>验证注解的元素值是true</td></tr><tr><td>@NotNull</td><td>任意类型</td><td>验证注解的元素值不是null</td></tr><tr><td>@Null</td><td>任意类型</td><td>验证注解的元素值是null</td></tr><tr><td>@Min(value&#x3D;值)</td><td>BigDecimal，BigInteger, byte,short, int, long，等任何Number或CharSequence（存储的是数字）子类型</td><td>验证注解的元素值大于等于@Min指定的value值</td></tr><tr><td>@Max（value&#x3D;值）</td><td>和@Min要求一样</td><td>验证注解的元素值小于等于@Max指定的value值</td></tr><tr><td>@DecimalMin(value&#x3D;值)</td><td>和@Min要求一样</td><td>验证注解的元素值大于等于@ DecimalMin指定的value值</td></tr><tr><td>@DecimalMax(value&#x3D;值)</td><td>和@Min要求一样</td><td>验证注解的元素值小于等于@ DecimalMax指定的value值</td></tr><tr><td>@Digits(integer&#x3D;整数位数, fraction&#x3D;小数位数)</td><td>和@Min要求一样</td><td>验证注解的元素值的整数位数和小数位数上限</td></tr><tr><td>@Size(min&#x3D;下限, max&#x3D;上限)</td><td>字符串、Collection、Map、数组等</td><td>验证注解的元素值的在min和max（包含）指定区间之内，如字符长度、集合大小</td></tr><tr><td>@Past</td><td>java.util.Date,java.util.Calendar;Joda Time类库的日期类型</td><td>验证注解的元素值（日期类型）比当前时间早</td></tr><tr><td>@Future</td><td>与@Past要求一样</td><td>验证注解的元素值（日期类型）比当前时间晚</td></tr><tr><td>@NotBlank</td><td>CharSequence子类型</td><td>验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank只应用于字符串且在比较时会去除字符串的首位空格</td></tr><tr><td>@Length(min&#x3D;下限, max&#x3D;上限)</td><td>CharSequence子类型</td><td>验证注解的元素值长度在min和max区间内</td></tr><tr><td>@NotEmpty</td><td>CharSequence子类型、Collection、Map、数组</td><td>验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）</td></tr><tr><td>@Range(min&#x3D;最小值, max&#x3D;最大值)</td><td>BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型</td><td>验证注解的元素值在最小值和最大值之间</td></tr><tr><td>@Email(regexp&#x3D;正则表达式,flag&#x3D;标志的模式)</td><td>CharSequence子类型（如String）</td><td>验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式</td></tr><tr><td>@Pattern(regexp&#x3D;正则表达式,flag&#x3D;标志的模式)</td><td>String，任何CharSequence的子类型</td><td>验证注解的元素值与指定的正则表达式匹配</td></tr><tr><td>@Valid</td><td>任何非原子类型</td><td>指定递归验证关联的对象如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加@Valid注解即可级联验证</td></tr></tbody></table><p>此处只列出Hibernate Validator提供的大部分验证约束注解，请参考hibernate validator官方文档了解其他验证约束注解和进行自定义的验证约束注解定义。</p><p><a href="https://docs.jboss.org/hibernate/validator/8.0/reference/en-US/html_single/#validator-gettingstarted">https://docs.jboss.org/hibernate/validator/8.0/reference/en-US/html_single/#validator-gettingstarted</a></p><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><h3 id="1-Validated-声明要检查的参数"><a href="#1-Validated-声明要检查的参数" class="headerlink" title="1. @Validated 声明要检查的参数"></a>1. @Validated 声明要检查的参数</h3><p>这里我们在控制器层进行注解声明</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 走参数校验注解</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param userDTO</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="variable">@PostMapping</span>(<span class="string">&quot;/save/valid&quot;</span>)</span><br><span class="line">   public RspDTO <span class="built_in">save</span>(<span class="variable">@RequestBody</span> <span class="variable">@Validated</span> UserDTO userDTO) &#123;</span><br><span class="line">       <span class="selector-tag">userService</span><span class="selector-class">.save</span>(userDTO);</span><br><span class="line">       <span class="selector-tag">return</span> <span class="selector-tag">RspDTO</span><span class="selector-class">.success</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-对参数的字段进行注解标注"><a href="#2-对参数的字段进行注解标注" class="headerlink" title="2. 对参数的字段进行注解标注"></a>2. 对参数的字段进行注解标注</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.*;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: UserDTO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 用户传输对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDTO</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 用户ID*/</span></span><br><span class="line">    <span class="meta">@NotNull(message = <span class="string">&quot;用户id不能为空&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Long</span> userId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 用户名*/</span></span><br><span class="line">    <span class="meta">@NotBlank(message = <span class="string">&quot;用户名不能为空&quot;</span>)</span></span><br><span class="line">    <span class="meta">@Length(max = 20, message = <span class="string">&quot;用户名不能超过20个字符&quot;</span>)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = <span class="string">&quot;^[\\u4E00-\\u9FA5A-Za-z0-9\\*]*$&quot;</span>, message = <span class="string">&quot;用户昵称限制：最多20字符，包含文字、字母和数字&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 手机号*/</span></span><br><span class="line">    <span class="meta">@NotBlank(message = <span class="string">&quot;手机号不能为空&quot;</span>)</span></span><br><span class="line">    <span class="meta">@Pattern(regexp = <span class="string">&quot;^[1][3,4,5,6,7,8,9][0-9]&#123;9&#125;$&quot;</span>, message = <span class="string">&quot;手机号格式有误&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**性别*/</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 邮箱*/</span></span><br><span class="line">    <span class="meta">@NotBlank(message = <span class="string">&quot;联系邮箱不能为空&quot;</span>)</span></span><br><span class="line">    <span class="meta">@Email(message = <span class="string">&quot;邮箱格式不对&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 密码*/</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 创建时间 */</span></span><br><span class="line">    <span class="meta">@Future(message = <span class="string">&quot;时间必须是将来时间&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-在全局校验中增加校验异常"><a href="#3-在全局校验中增加校验异常" class="headerlink" title="3. 在全局校验中增加校验异常"></a>3. 在全局校验中增加校验异常</h3><p><code>MethodArgumentNotValidException</code>是springBoot中进行绑定参数校验时的异常,需要在springBoot中处理,其他需要 处理ConstraintViolationException异常进行处理.</p><ul><li>为了优雅一点,我们将参数异常,业务异常,统一做了一个全局异常,将控制层的异常包装到我们自定义的异常中</li><li>为了优雅一点,我们还做了一个统一的结构体,将请求的code,和msg,data一起统一封装到结构体中,增加了代码的复用性</li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import com.boot.lea.mybot.dto.RspDTO;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.dao.DuplicateKeyException;</span><br><span class="line">import org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line">import org.springframework.web.servlet.NoHandlerFoundException;</span><br><span class="line"></span><br><span class="line">import javax.validation.ConstraintViolationException;</span><br><span class="line">import javax.validation.ValidationException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ClassName: GlobalExceptionHandler</span></span><br><span class="line"><span class="comment"> * @Description: 全局异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public <span class="keyword">class</span> GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(<span class="params">getClass</span>()</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="built_in">int</span> DUPLICATE_KEY_CODE = <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">private</span> static <span class="built_in">int</span> PARAM_FAIL_CODE = <span class="number">1002</span>;</span><br><span class="line">    <span class="keyword">private</span> static <span class="built_in">int</span> VALIDATION_CODE = <span class="number">1003</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自定义异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="constructor">ExceptionHandler(BizException.<span class="params">class</span>)</span></span><br><span class="line">    public RspDTO handle<span class="constructor">RRException(BizException <span class="params">e</span>)</span> &#123;</span><br><span class="line">        logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">RspDTO(<span class="params">e</span>.<span class="params">getCode</span>()</span>, e.get<span class="constructor">Message()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数校验</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="constructor">ExceptionHandler(MethodArgumentNotValidException.<span class="params">class</span>)</span></span><br><span class="line">    public RspDTO handle<span class="constructor">MethodArgumentNotValidException(MethodArgumentNotValidException <span class="params">e</span>)</span> &#123;</span><br><span class="line">        logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">RspDTO(PARAM_FAIL_CODE, <span class="params">e</span>.<span class="params">getBindingResult</span>()</span>.get<span class="constructor">FieldError()</span>.get<span class="constructor">DefaultMessage()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ValidationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="constructor">ExceptionHandler(ValidationException.<span class="params">class</span>)</span></span><br><span class="line">    public RspDTO handle<span class="constructor">ValidationException(ValidationException <span class="params">e</span>)</span> &#123;</span><br><span class="line">        logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">RspDTO(VALIDATION_CODE, <span class="params">e</span>.<span class="params">getCause</span>()</span>.get<span class="constructor">Message()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ConstraintViolationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @<span class="constructor">ExceptionHandler(ConstraintViolationException.<span class="params">class</span>)</span></span><br><span class="line">    public RspDTO handle<span class="constructor">ConstraintViolationException(ConstraintViolationException <span class="params">e</span>)</span> &#123;</span><br><span class="line">        logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">RspDTO(PARAM_FAIL_CODE, <span class="params">e</span>.<span class="params">getMessage</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="constructor">ExceptionHandler(NoHandlerFoundException.<span class="params">class</span>)</span></span><br><span class="line">    public RspDTO handler<span class="constructor">NoFoundException(Exception <span class="params">e</span>)</span> &#123;</span><br><span class="line">        logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">RspDTO(404, <span class="string">&quot;路径不存在，请检查路径是否正确&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="constructor">ExceptionHandler(DuplicateKeyException.<span class="params">class</span>)</span></span><br><span class="line">    public RspDTO handle<span class="constructor">DuplicateKeyException(DuplicateKeyException <span class="params">e</span>)</span> &#123;</span><br><span class="line">        logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">RspDTO(DUPLICATE_KEY_CODE, <span class="string">&quot;数据重复，请检查后提交&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @<span class="constructor">ExceptionHandler(Exception.<span class="params">class</span>)</span></span><br><span class="line">    public RspDTO handle<span class="constructor">Exception(Exception <span class="params">e</span>)</span> &#123;</span><br><span class="line">        logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">RspDTO(500, <span class="string">&quot;系统繁忙,请稍后再试&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义参数注解"><a href="#自定义参数注解" class="headerlink" title="自定义参数注解"></a>自定义参数注解</h2><h3 id="第一步、创建自定义注解"><a href="#第一步、创建自定义注解" class="headerlink" title="第一步、创建自定义注解"></a>第一步、创建自定义注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(EnumString.List.class)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = EnumStringValidator.class)</span><span class="comment">//标明由哪个类执行校验逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnumString &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;value not in enum values.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> date must in this value array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Defines several &#123;<span class="doctag">@link</span> EnumString&#125; annotations on the same element.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> EnumString</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@interface</span> List &#123;</span><br><span class="line"></span><br><span class="line">        EnumString[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以根据Validator框架定义好的注解来仿写，基本上一致</p></blockquote><h3 id="第二步、自定义校验逻辑"><a href="#第二步、自定义校验逻辑" class="headerlink" title="第二步、自定义校验逻辑"></a>第二步、自定义校验逻辑</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumStringValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;EnumString, String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; enumStringList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(EnumString constraintAnnotation)</span> &#123;</span><br><span class="line">        enumStringList = Arrays.asList(constraintAnnotation.value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enumStringList.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="第三步、在字段上增加注解"><a href="#第三步、在字段上增加注解" class="headerlink" title="第三步、在字段上增加注解"></a>第三步、在字段上增加注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnumString(value = &#123;&quot;F&quot;,&quot;M&quot;&#125;, message=&quot;性别只允许为F或M&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String sex;</span><br></pre></td></tr></table></figure><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p>一个VO对象在新增的时候某些字段为必填，在更新的时候又非必填。如<code>ValidVO</code>中 id 和 appId 属性在新增操作时都是<strong>非必填</strong>，而在编辑操作时都为<strong>必填</strong>，name在新增操作时为<strong>必填</strong>，面对这种场景你会怎么处理呢？</p><p>在实际开发中很多同学都是建立两个VO对象，<code>ValidCreateVO</code>，<code>ValidEditVO</code>来处理这种场景，这样确实也能实现效果，但是会造成类膨胀。</p><blockquote><p>其实<code>Validator</code>校验框架已经考虑到了这种场景并且提供了解决方案，就是<strong>分组校验</strong></p></blockquote><p><strong>要使用分组校验，只需要三个步骤</strong></p><h3 id="第一步，定义分组接口"><a href="#第一步，定义分组接口" class="headerlink" title="第一步，定义分组接口"></a>第一步，定义分组接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidGroup</span> <span class="keyword">extends</span> <span class="title class_">Default</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Crud</span> <span class="keyword">extends</span> <span class="title class_">ValidGroup</span>&#123;</span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Create</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Update</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Query</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Delete</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们定义一个分组接口ValidGroup让其继承<code>javax.validation.groups.Default</code>，再在分组接口中定义出多个不同的操作类型，Create，Update，Query，Delete。</p></blockquote><h3 id="第二步，在模型中给参数分配分组"><a href="#第二步，在模型中给参数分配分组" class="headerlink" title="第二步，在模型中给参数分配分组"></a>第二步，在模型中给参数分配分组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidVO</span> &#123;</span><br><span class="line">    <span class="meta">@Null(groups = ValidGroup.Crud.Create.class)</span></span><br><span class="line">    <span class="meta">@NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Length(min = 6,max = 12,message = &quot;appId长度必须位于6到12之间&quot;)</span></span><br><span class="line">    <span class="meta">@Null(groups = ValidGroup.Crud.Create.class)</span></span><br><span class="line">    <span class="meta">@NotNull(groups = ValidGroup.Crud.Update.class, message = &quot;应用ID不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;名字为必填项&quot;)</span></span><br><span class="line">    <span class="meta">@NotBlank(groups = ValidGroup.Crud.Create.class,message = &quot;名字为必填项&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;请填写正确的邮箱地址&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumString(value = &#123;&quot;F&quot;,&quot;M&quot;&#125;, message=&quot;性别只允许为F或M&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty(message = &quot;级别不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>由于email属于默认分组，而我们的分组接口<code>ValidGroup</code>已经继承了<code>Default</code>分组，所以也是可以对email字段作参数校验的。</p><p>当然如果你的ValidGroup没有继承Default分组，那在代码属性上就需要加上<code>@Validated(value = &#123;ValidGroup.Crud.Create.class, Default.class&#125;</code>才能让<code>email</code>字段的校验生效。</p></blockquote><h3 id="第三步，给需要参数校验的方法指定分组"><a href="#第三步，给需要参数校验的方法指定分组" class="headerlink" title="第三步，给需要参数校验的方法指定分组"></a>第三步，给需要参数校验的方法指定分组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Create.class)</span> ValidVO validVO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test3 valid success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/valid/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Update.class)</span> ValidVO validVO)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;validEntity is &#123;&#125;&quot;</span>, validVO);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test4 valid success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="业务规则校验"><a href="#业务规则校验" class="headerlink" title="业务规则校验"></a>业务规则校验</h2><p><a href="https://juejin.cn/post/7062529892696457223">juejin.cn&#x2F;post&#x2F;706252…</a></p><p>业务规则校验指接口需要满足某些特定的业务规则，举个例子：业务系统的用户需要保证其唯一性，用户属性不能与其他用户产生冲突，不允许与数据库中任何已有用户的用户名称、手机号码、邮箱产生重复。</p><p>这就要求在<strong>创建用户时需要校验用户名称、手机号码、邮箱是否被注册</strong>；<strong>编辑用户时不能将信息修改成已有用户的属性</strong>。</p><blockquote><p><strong>最优雅的实现方法应该是参考 Bean Validation 的标准方式，借助自定义校验注解完成业务规则校验。</strong></p></blockquote><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>首先我们需要创建两个自定义注解，用于业务规则校验：</p><ul><li><p><code>UniqueUser</code>:表示一个用户是唯一的，唯一性包含：用户名，手机号码、邮箱</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;FIELD, METHOD, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = UserValidation.UniqueUserValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UniqueUser &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;用户名、手机号码、邮箱不允许与现存用户重复&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>NotConflictUser</code>:表示一个用户的信息是无冲突的，无冲突是指该用户的敏感信息与其他用户不重合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;FIELD, METHOD, PARAMETER, TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = UserValidation.NotConflictUserValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NotConflictUser &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;用户名称、邮箱、手机号码与现存用户产生重复&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现业务校验规则"><a href="#实现业务校验规则" class="headerlink" title="实现业务校验规则"></a>实现业务校验规则</h3><blockquote><p>想让自定义验证注解生效，需要实现 <code>ConstraintValidator</code> 接口。</p></blockquote><p>**接口的第一个参数是 **自定义注解类型**，第二个参数是 **被注解字段的类**，因为需要校验多个参数，我们直接传入用户对象。**需要提到的一点是 <code>ConstraintValidator</code> 接口的实现类无需添加 <code>@Component</code> 它在启动的时候就已经被加载到容器中了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java复制代码<span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserValidation</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;T, User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Predicate&lt;User&gt; predicate = c -&gt; <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">protected</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(User user, ConstraintValidatorContext constraintValidatorContext)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userRepository == <span class="literal">null</span> || predicate.test(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验用户是否唯一</span></span><br><span class="line"><span class="comment">     * 即判断数据库是否存在当前新用户的信息，如用户名，手机，邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UniqueUserValidator</span> <span class="keyword">extends</span> <span class="title class_">UserValidation</span>&lt;UniqueUser&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(UniqueUser uniqueUser)</span> &#123;</span><br><span class="line">            predicate = c -&gt; !userRepository.existsByUserNameOrEmailOrTelphone(c.getUserName(),c.getEmail(),c.getTelphone());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验是否与其他用户冲突</span></span><br><span class="line"><span class="comment">     * 将用户名、邮件、电话改成与现有完全不重复的，或者只与自己重复的，就不算冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NotConflictUserValidator</span> <span class="keyword">extends</span> <span class="title class_">UserValidation</span>&lt;NotConflictUser&gt;&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(NotConflictUser notConflictUser)</span> &#123;</span><br><span class="line">            predicate = c -&gt; &#123;</span><br><span class="line">                log.info(<span class="string">&quot;user detail is &#123;&#125;&quot;</span>,c);</span><br><span class="line">                Collection&lt;User&gt; collection = userRepository.findByUserNameOrEmailOrTelphone(c.getUserName(), c.getEmail(), c.getTelphone());</span><br><span class="line">                <span class="comment">// 将用户名、邮件、电话改成与现有完全不重复的，或者只与自己重复的，就不算冲突</span></span><br><span class="line">                <span class="keyword">return</span> collection.isEmpty() || (collection.size() == <span class="number">1</span> &amp;&amp; collection.iterator().next().getId().equals(c.getId()));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>这里使用Predicate函数式接口对业务规则进行判断。</strong></p></blockquote><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/senior/user&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(<span class="meta">@UniqueUser</span> <span class="meta">@Valid</span> User user)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">savedUser</span> <span class="operator">=</span> userRepository.save(user);</span><br><span class="line">        log.info(<span class="string">&quot;save user id is &#123;&#125;&quot;</span>,savedUser.getId());</span><br><span class="line">        <span class="keyword">return</span> savedUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUser</span><span class="params">(<span class="meta">@NotConflictUser</span> <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">editUser</span> <span class="operator">=</span> userRepository.save(user);</span><br><span class="line">        log.info(<span class="string">&quot;update user is &#123;&#125;&quot;</span>,editUser);</span><br><span class="line">        <span class="keyword">return</span> editUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用很简单，只需要在方法上加入自定义注解即可，业务逻辑中不需要添加任何业务规则的代码。</p></blockquote><h2 id="restful风格用法"><a href="#restful风格用法" class="headerlink" title="restful风格用法"></a>restful风格用法</h2><p>在多个参数校验,或者@RequestParam 形式时候,需要在controller上加注@Validated</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RspDTO getUser(<span class="meta">@RequestParam(<span class="string">&quot;userId&quot;</span>)</span> <span class="meta">@NotNull(message = <span class="string">&quot;用户id不能为空&quot;</span>)</span> <span class="built_in">Long</span> userId) &#123;</span><br><span class="line">    User user = userService.selectById(userId);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> new RspDTO&lt;User&gt;().nonAbsent(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new RspDTO&lt;User&gt;().success(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;user/&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">extends</span> <span class="title class_">AbstractController</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://juejin.cn/post/7183534486632529980#heading-0">如何优雅实现参数的各种校验 - 掘金 (juejin.cn)</a></li><li><a href="https://juejin.cn/post/7109131754182541348#heading-0">SpringBoot参数校验——Validator框架 - 掘金 (juejin.cn)</a></li><li><a href="https://developer.aliyun.com/article/786719#slide-0">SpringBoot 如何进行参数校验，老鸟们都这么玩的！-阿里云开发者社区 (aliyun.com)</a></li><li><a href="https://juejin.cn/post/7062529892696457223#heading-0">SpringBoot中实现业务校验，这种方式才叫优雅！ - 掘金 (juejin.cn)</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247489603&idx=2&sn=c7a766500122c02694860bd2470204cf&chksm=ebd6276fdca1ae7997a98d8c038ad3462c7ee9b492f28b4de8b7461ca0965fac55d94f96dd37&scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247489603&amp;idx=2&amp;sn=c7a766500122c02694860bd2470204cf&amp;chksm=ebd6276fdca1ae7997a98d8c038ad3462c7ee9b492f28b4de8b7461ca0965fac55d94f96dd37&amp;scene=21#wechat_redirect</a></li><li><a href="https://javadaily.cn/post/2022012731/dc48fbdfae7c/">SpringBoot 如何进行参数校验，老鸟们都这么玩的！ | Java日知录 (javadaily.cn)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 参数校验 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
